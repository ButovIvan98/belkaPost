{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define(\"Centrifuge\", [], factory);else if (typeof exports === 'object') exports[\"Centrifuge\"] = factory();else root[\"Centrifuge\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            /******/\n            configurable: false,\n\n            /******/\n            enumerable: true,\n\n            /******/\n            get: getter\n            /******/\n\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 31);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    {\n      /***/\n      10:\n      /***/\n      function (module, exports, __webpack_require__) {\n        \"use strict\";\n        /* WEBPACK VAR INJECTION */\n\n        (function (global) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.Centrifuge = undefined;\n\n          var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n            return typeof obj;\n          } : function (obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n\n          var _createClass = function () {\n            function defineProperties(target, props) {\n              for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n              }\n            }\n\n            return function (Constructor, protoProps, staticProps) {\n              if (protoProps) defineProperties(Constructor.prototype, protoProps);\n              if (staticProps) defineProperties(Constructor, staticProps);\n              return Constructor;\n            };\n          }();\n\n          var _events = __webpack_require__(6);\n\n          var _events2 = _interopRequireDefault(_events);\n\n          var _subscription = __webpack_require__(11);\n\n          var _subscription2 = _interopRequireDefault(_subscription);\n\n          var _json = __webpack_require__(12);\n\n          var _utils = __webpack_require__(7);\n\n          function _interopRequireDefault(obj) {\n            return obj && obj.__esModule ? obj : {\n              default: obj\n            };\n          }\n\n          function _classCallCheck(instance, Constructor) {\n            if (!(instance instanceof Constructor)) {\n              throw new TypeError(\"Cannot call a class as a function\");\n            }\n          }\n\n          function _possibleConstructorReturn(self, call) {\n            if (!self) {\n              throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            }\n\n            return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n          }\n\n          function _inherits(subClass, superClass) {\n            if (typeof superClass !== \"function\" && superClass !== null) {\n              throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n            }\n\n            subClass.prototype = Object.create(superClass && superClass.prototype, {\n              constructor: {\n                value: subClass,\n                enumerable: false,\n                writable: true,\n                configurable: true\n              }\n            });\n            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n          }\n\n          var _errorTimeout = 'timeout';\n          var _errorConnectionClosed = 'connection closed';\n\n          var Centrifuge = exports.Centrifuge = function (_EventEmitter) {\n            _inherits(Centrifuge, _EventEmitter);\n\n            function Centrifuge(url, options) {\n              _classCallCheck(this, Centrifuge);\n\n              var _this = _possibleConstructorReturn(this, (Centrifuge.__proto__ || Object.getPrototypeOf(Centrifuge)).call(this));\n\n              _this._url = url;\n              _this._websocket = null;\n              _this._sockjs = null;\n              _this._isSockjs = false;\n              _this._binary = false;\n              _this._methodType = null;\n              _this._pushType = null;\n              _this._encoder = null;\n              _this._decoder = null;\n              _this._status = 'disconnected';\n              _this._reconnect = true;\n              _this._reconnecting = false;\n              _this._transport = null;\n              _this._transportName = null;\n              _this._transportClosed = true;\n              _this._messageId = 0;\n              _this._clientID = null;\n              _this._refreshRequired = false;\n              _this._subs = {};\n              _this._lastSeq = {};\n              _this._lastGen = {};\n              _this._lastEpoch = {};\n              _this._messages = [];\n              _this._isBatching = false;\n              _this._isSubscribeBatching = false;\n              _this._privateChannels = {};\n              _this._numRefreshFailed = 0;\n              _this._refreshTimeout = null;\n              _this._pingTimeout = null;\n              _this._pongTimeout = null;\n              _this._subRefreshTimeouts = {};\n              _this._retries = 0;\n              _this._callbacks = {};\n              _this._latency = null;\n              _this._latencyStart = null;\n              _this._connectData = null;\n              _this._token = null;\n              _this._xhrID = 0;\n              _this._xhrs = {};\n              _this._config = {\n                debug: false,\n                websocket: null,\n                sockjs: null,\n                promise: null,\n                minRetry: 1000,\n                maxRetry: 20000,\n                timeout: 5000,\n                ping: true,\n                pingInterval: 25000,\n                pongWaitTimeout: 5000,\n                privateChannelPrefix: '$',\n                onTransportClose: null,\n                sockjsServer: null,\n                sockjsTransports: ['websocket', 'xdr-streaming', 'xhr-streaming', 'eventsource', 'iframe-eventsource', 'iframe-htmlfile', 'xdr-polling', 'xhr-polling', 'iframe-xhr-polling', 'jsonp-polling'],\n                refreshEndpoint: '/centrifuge/refresh',\n                refreshHeaders: {},\n                refreshParams: {},\n                refreshData: {},\n                refreshAttempts: null,\n                refreshInterval: 1000,\n                onRefreshFailed: null,\n                onRefresh: null,\n                subscribeEndpoint: '/centrifuge/subscribe',\n                subscribeHeaders: {},\n                subscribeParams: {},\n                subRefreshInterval: 1000,\n                onPrivateSubscribe: null\n              };\n\n              _this._configure(options);\n\n              return _this;\n            }\n\n            _createClass(Centrifuge, [{\n              key: 'setToken',\n              value: function setToken(token) {\n                this._token = token;\n              }\n            }, {\n              key: 'setConnectData',\n              value: function setConnectData(data) {\n                this._connectData = data;\n              }\n            }, {\n              key: 'setRefreshHeaders',\n              value: function setRefreshHeaders(headers) {\n                this._config.refreshHeaders = headers;\n              }\n            }, {\n              key: 'setRefreshParams',\n              value: function setRefreshParams(params) {\n                this._config.refreshParams = params;\n              }\n            }, {\n              key: 'setRefreshData',\n              value: function setRefreshData(data) {\n                this._config.refreshData = data;\n              }\n            }, {\n              key: 'setSubscribeHeaders',\n              value: function setSubscribeHeaders(headers) {\n                this._config.subscribeHeaders = headers;\n              }\n            }, {\n              key: 'setSubscribeParams',\n              value: function setSubscribeParams(params) {\n                this._config.subscribeParams = params;\n              }\n            }, {\n              key: '_ajax',\n              value: function _ajax(url, params, headers, data, callback) {\n                var _this2 = this;\n\n                var query = '';\n\n                this._debug('sending AJAX request to', url, 'with data', JSON.stringify(data));\n\n                var xhr = global.XMLHttpRequest ? new global.XMLHttpRequest() : new global.ActiveXObject('Microsoft.XMLHTTP');\n\n                for (var i in params) {\n                  if (params.hasOwnProperty(i)) {\n                    if (query.length > 0) {\n                      query += '&';\n                    }\n\n                    query += encodeURIComponent(i) + '=' + encodeURIComponent(params[i]);\n                  }\n                }\n\n                if (query.length > 0) {\n                  query = '?' + query;\n                }\n\n                xhr.open('POST', url + query, true);\n\n                if ('withCredentials' in xhr) {\n                  xhr.withCredentials = true;\n                }\n\n                xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n                xhr.setRequestHeader('Content-Type', 'application/json');\n\n                for (var headerName in headers) {\n                  if (headers.hasOwnProperty(headerName)) {\n                    xhr.setRequestHeader(headerName, headers[headerName]);\n                  }\n                }\n\n                xhr.onreadystatechange = function () {\n                  if (xhr.readyState === 4) {\n                    if (xhr.status === 200) {\n                      var _data = void 0,\n                          parsed = false;\n\n                      try {\n                        _data = JSON.parse(xhr.responseText);\n                        parsed = true;\n                      } catch (e) {\n                        callback({\n                          error: 'Invalid JSON. Data was: ' + xhr.responseText,\n                          status: 200,\n                          data: null\n                        });\n                      }\n\n                      if (parsed) {\n                        // prevents double execution.\n                        callback({\n                          data: _data,\n                          status: 200\n                        });\n                      }\n                    } else {\n                      _this2._log('wrong status code in AJAX response', xhr.status);\n\n                      callback({\n                        status: xhr.status,\n                        data: null\n                      });\n                    }\n                  }\n                };\n\n                setTimeout(function () {\n                  return xhr.send(JSON.stringify(data));\n                }, 20);\n                return xhr;\n              }\n            }, {\n              key: '_log',\n              value: function _log() {\n                (0, _utils.log)('info', arguments);\n              }\n            }, {\n              key: '_debug',\n              value: function _debug() {\n                if (this._config.debug === true) {\n                  (0, _utils.log)('debug', arguments);\n                }\n              }\n            }, {\n              key: '_websocketSupported',\n              value: function _websocketSupported() {\n                if (this._config.websocket !== null) {\n                  return true;\n                }\n\n                return !(typeof WebSocket !== 'function' && (typeof WebSocket === 'undefined' ? 'undefined' : _typeof(WebSocket)) !== 'object');\n              }\n            }, {\n              key: '_setFormat',\n              value: function _setFormat(format) {\n                if (this._formatOverride(format)) {\n                  return;\n                }\n\n                if (format === 'protobuf') {\n                  throw new Error('not implemented by JSON only Centrifuge client â€“ use client with Protobuf');\n                }\n\n                this._binary = false;\n                this._methodType = _json.JsonMethodType;\n                this._pushType = _json.JsonPushType;\n                this._encoder = new _json.JsonEncoder();\n                this._decoder = new _json.JsonDecoder();\n              }\n            }, {\n              key: '_formatOverride',\n              value: function _formatOverride(format) {\n                return false;\n              }\n            }, {\n              key: '_configure',\n              value: function _configure(configuration) {\n                if (!('Promise' in global)) {\n                  throw new Error('Promise polyfill required');\n                }\n\n                (0, _utils.extend)(this._config, configuration || {});\n\n                this._debug('centrifuge config', this._config);\n\n                if (!this._url) {\n                  throw new Error('url required');\n                }\n\n                if ((0, _utils.startsWith)(this._url, 'ws') && this._url.indexOf('format=protobuf') > -1) {\n                  this._setFormat('protobuf');\n                } else {\n                  this._setFormat('json');\n                }\n\n                if ((0, _utils.startsWith)(this._url, 'http')) {\n                  this._debug('client will try to connect to SockJS endpoint');\n\n                  if (this._config.sockjs !== null) {\n                    this._debug('SockJS explicitly provided in options');\n\n                    this._sockjs = this._config.sockjs;\n                  } else {\n                    if (typeof global.SockJS === 'undefined') {\n                      throw new Error('SockJS not found, use ws:// in url or include SockJS');\n                    }\n\n                    this._debug('use globally defined SockJS');\n\n                    this._sockjs = global.SockJS;\n                  }\n                } else {\n                  this._debug('client will connect to websocket endpoint');\n                }\n              }\n            }, {\n              key: '_setStatus',\n              value: function _setStatus(newStatus) {\n                if (this._status !== newStatus) {\n                  this._debug('Status', this._status, '->', newStatus);\n\n                  this._status = newStatus;\n                }\n              }\n            }, {\n              key: '_isDisconnected',\n              value: function _isDisconnected() {\n                return this._status === 'disconnected';\n              }\n            }, {\n              key: '_isConnecting',\n              value: function _isConnecting() {\n                return this._status === 'connecting';\n              }\n            }, {\n              key: '_isConnected',\n              value: function _isConnected() {\n                return this._status === 'connected';\n              }\n            }, {\n              key: '_nextMessageId',\n              value: function _nextMessageId() {\n                return ++this._messageId;\n              }\n            }, {\n              key: '_resetRetry',\n              value: function _resetRetry() {\n                this._debug('reset retries count to 0');\n\n                this._retries = 0;\n              }\n            }, {\n              key: '_getRetryInterval',\n              value: function _getRetryInterval() {\n                var interval = (0, _utils.backoff)(this._retries, this._config.minRetry, this._config.maxRetry);\n                this._retries += 1;\n                return interval;\n              }\n            }, {\n              key: '_abortInflightXHRs',\n              value: function _abortInflightXHRs() {\n                for (var xhrID in this._xhrs) {\n                  try {\n                    this._xhrs[xhrID].abort();\n                  } catch (e) {\n                    this._debug('error aborting xhr', e);\n                  }\n\n                  delete this._xhrs[xhrID];\n                }\n              }\n            }, {\n              key: '_clearConnectedState',\n              value: function _clearConnectedState(reconnect) {\n                this._clientID = null;\n\n                this._stopPing(); // fire errbacks of registered outgoing calls.\n\n\n                for (var id in this._callbacks) {\n                  if (this._callbacks.hasOwnProperty(id)) {\n                    var callbacks = this._callbacks[id];\n                    clearTimeout(callbacks.timeout);\n                    var errback = callbacks.errback;\n\n                    if (!errback) {\n                      continue;\n                    }\n\n                    errback({\n                      error: this._createErrorObject('disconnected')\n                    });\n                  }\n                }\n\n                this._callbacks = {}; // fire unsubscribe events\n\n                for (var channel in this._subs) {\n                  if (this._subs.hasOwnProperty(channel)) {\n                    var sub = this._subs[channel];\n\n                    if (reconnect) {\n                      if (sub._isSuccess()) {\n                        sub._triggerUnsubscribe();\n\n                        sub._recover = true;\n                      }\n\n                      if (sub._shouldResubscribe()) {\n                        sub._setSubscribing();\n                      }\n                    } else {\n                      sub._setUnsubscribed();\n                    }\n                  }\n                }\n\n                this._abortInflightXHRs(); // clear refresh timer\n\n\n                if (this._refreshTimeout !== null) {\n                  clearTimeout(this._refreshTimeout);\n                  this._refreshTimeout = null;\n                } // clear sub refresh timers\n\n\n                for (var _channel in this._subRefreshTimeouts) {\n                  if (this._subRefreshTimeouts.hasOwnProperty(_channel) && this._subRefreshTimeouts[_channel]) {\n                    this._clearSubRefreshTimeout(_channel);\n                  }\n                }\n\n                this._subRefreshTimeouts = {};\n\n                if (!this._reconnect) {\n                  // completely clear subscriptions\n                  this._subs = {};\n                }\n              }\n            }, {\n              key: '_isTransportOpen',\n              value: function _isTransportOpen() {\n                if (this._isSockjs) {\n                  return this._transport && this._transport.transport && this._transport.transport.readyState === this._transport.transport.OPEN;\n                }\n\n                return this._transport && this._transport.readyState === this._transport.OPEN;\n              }\n            }, {\n              key: '_transportSend',\n              value: function _transportSend(commands) {\n                if (!commands.length) {\n                  return true;\n                }\n\n                if (!this._isTransportOpen()) {\n                  // resolve pending commands with error if transport is not open\n                  for (var command in commands) {\n                    var id = command.id;\n\n                    if (!(id in this._callbacks)) {\n                      continue;\n                    }\n\n                    var callbacks = this._callbacks[id];\n                    clearTimeout(this._callbacks[id].timeout);\n                    delete this._callbacks[id];\n                    var errback = callbacks.errback;\n                    errback({\n                      error: this._createErrorObject(_errorConnectionClosed, 0)\n                    });\n                  }\n\n                  return false;\n                }\n\n                this._transport.send(this._encoder.encodeCommands(commands));\n\n                return true;\n              }\n            }, {\n              key: '_setupTransport',\n              value: function _setupTransport() {\n                var _this3 = this;\n\n                this._isSockjs = false; // detect transport to use - SockJS or Websocket\n\n                if (this._sockjs !== null) {\n                  var sockjsOptions = {\n                    transports: this._config.sockjsTransports\n                  };\n\n                  if (this._config.sockjsServer !== null) {\n                    sockjsOptions.server = this._config.sockjsServer;\n                  }\n\n                  this._isSockjs = true;\n                  this._transport = new this._sockjs(this._url, null, sockjsOptions);\n                } else {\n                  if (!this._websocketSupported()) {\n                    this._debug('No Websocket support and no SockJS configured, can not connect');\n\n                    return;\n                  }\n\n                  if (this._config.websocket !== null) {\n                    this._websocket = this._config.websocket;\n                  } else {\n                    this._websocket = WebSocket;\n                  }\n\n                  this._transport = new this._websocket(this._url);\n\n                  if (this._binary === true) {\n                    this._transport.binaryType = 'arraybuffer';\n                  }\n                }\n\n                this._transport.onopen = function () {\n                  _this3._transportClosed = false;\n\n                  if (_this3._isSockjs) {\n                    _this3._transportName = 'sockjs-' + _this3._transport.transport;\n\n                    _this3._transport.onheartbeat = function () {\n                      return _this3._restartPing();\n                    };\n                  } else {\n                    _this3._transportName = 'websocket';\n                  } // Can omit method here due to zero value.\n\n\n                  var msg = {// method: this._methodType.CONNECT\n                  };\n\n                  if (_this3._token || _this3._connectData) {\n                    msg.params = {};\n                  }\n\n                  if (_this3._token) {\n                    msg.params.token = _this3._token;\n                  }\n\n                  if (_this3._connectData) {\n                    msg.params.data = _this3._connectData;\n                  }\n\n                  _this3._latencyStart = new Date();\n\n                  _this3._call(msg).then(function (resolveCtx) {\n                    _this3._connectResponse(_this3._decoder.decodeCommandResult(_this3._methodType.CONNECT, resolveCtx.result));\n\n                    if (resolveCtx.next) {\n                      resolveCtx.next();\n                    }\n                  }, function (rejectCtx) {\n                    var err = rejectCtx.error;\n\n                    if (err.code === 109) {\n                      // token expired.\n                      _this3._refreshRequired = true;\n                    }\n\n                    _this3._disconnect('connect error', true);\n\n                    if (rejectCtx.next) {\n                      rejectCtx.next();\n                    }\n                  });\n                };\n\n                this._transport.onerror = function (error) {\n                  _this3._debug('transport level error', error);\n                };\n\n                this._transport.onclose = function (closeEvent) {\n                  _this3._transportClosed = true;\n                  var reason = _errorConnectionClosed;\n                  var needReconnect = true;\n\n                  if (closeEvent && 'reason' in closeEvent && closeEvent.reason) {\n                    try {\n                      var advice = JSON.parse(closeEvent.reason);\n\n                      _this3._debug('reason is an advice object', advice);\n\n                      reason = advice.reason;\n                      needReconnect = advice.reconnect;\n                    } catch (e) {\n                      reason = closeEvent.reason;\n\n                      _this3._debug('reason is a plain string', reason);\n                    }\n                  } // onTransportClose callback should be executed every time transport was closed.\n                  // This can be helpful to catch failed connection events (because our disconnect\n                  // event only called once and every future attempts to connect do not fire disconnect\n                  // event again).\n\n\n                  if (_this3._config.onTransportClose !== null) {\n                    _this3._config.onTransportClose({\n                      event: closeEvent,\n                      reason: reason,\n                      reconnect: needReconnect\n                    });\n                  }\n\n                  _this3._disconnect(reason, needReconnect);\n\n                  if (_this3._reconnect === true) {\n                    _this3._reconnecting = true;\n\n                    var interval = _this3._getRetryInterval();\n\n                    _this3._debug('reconnect after ' + interval + ' milliseconds');\n\n                    setTimeout(function () {\n                      if (_this3._reconnect === true) {\n                        if (_this3._refreshRequired) {\n                          _this3._refresh();\n                        } else {\n                          _this3._connect();\n                        }\n                      }\n                    }, interval);\n                  }\n                };\n\n                this._transport.onmessage = function (event) {\n                  _this3._dataReceived(event.data);\n                };\n              }\n            }, {\n              key: 'rpc',\n              value: function rpc(data) {\n                var _this4 = this;\n\n                var msg = {\n                  method: this._methodType.RPC,\n                  params: {\n                    data: data\n                  }\n                };\n\n                if (!this.isConnected()) {\n                  return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n                }\n\n                return this._call(msg).then(function (resolveCtx) {\n                  if (resolveCtx.next) {\n                    resolveCtx.next();\n                  }\n\n                  return _this4._decoder.decodeCommandResult(_this4._methodType.RPC, resolveCtx.result);\n                }, function (rejectCtx) {\n                  if (rejectCtx.next) {\n                    rejectCtx.next();\n                  }\n\n                  return Promise.reject(rejectCtx.error);\n                });\n              }\n            }, {\n              key: 'send',\n              value: function send(data) {\n                var msg = {\n                  method: this._methodType.SEND,\n                  params: {\n                    data: data\n                  }\n                };\n\n                if (!this.isConnected()) {\n                  return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n                }\n\n                var sent = this._transportSend([msg]); // can send async message to server without id set\n\n\n                if (!sent) {\n                  return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n                }\n\n                ;\n                return Promise.resolve({});\n              }\n            }, {\n              key: 'publish',\n              value: function publish(channel, data) {\n                var msg = {\n                  method: this._methodType.PUBLISH,\n                  params: {\n                    channel: channel,\n                    data: data\n                  }\n                };\n\n                if (!this.isConnected()) {\n                  return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n                }\n\n                return this._call(msg).then(function (result) {\n                  if (result.next) {\n                    result.next();\n                  }\n\n                  return {};\n                });\n              }\n            }, {\n              key: '_dataReceived',\n              value: function _dataReceived(data) {\n                var _this5 = this;\n\n                var replies = this._decoder.decodeReplies(data); // we have to guarantee order of events in replies processing - i.e. start processing\n                // next reply only when we finished processing of current one. Without syncing things in\n                // this way we could get wrong publication events order as reply promises resolve\n                // on next loop tick so for loop continues before we finished emitting all reply events.\n\n\n                var p = Promise.resolve();\n\n                var _loop = function _loop(i) {\n                  if (replies.hasOwnProperty(i)) {\n                    p = p.then(function () {\n                      return _this5._dispatchReply(replies[i]);\n                    });\n                  }\n                };\n\n                for (var i in replies) {\n                  _loop(i);\n                }\n\n                this._restartPing();\n              }\n            }, {\n              key: '_call',\n              value: function _call(msg) {\n                var _this6 = this;\n\n                return new Promise(function (resolve, reject) {\n                  var id = _this6._addMessage(msg);\n\n                  _this6._registerCall(id, resolve, reject);\n                });\n              }\n            }, {\n              key: '_connect',\n              value: function _connect() {\n                if (this.isConnected()) {\n                  this._debug('connect called when already connected');\n\n                  return;\n                }\n\n                if (this._status === 'connecting') {\n                  return;\n                }\n\n                this._debug('start connecting');\n\n                this._setStatus('connecting');\n\n                this._clientID = null;\n                this._reconnect = true;\n\n                this._setupTransport();\n              }\n            }, {\n              key: '_disconnect',\n              value: function _disconnect(reason, shouldReconnect) {\n                var reconnect = shouldReconnect || false;\n\n                if (reconnect === false) {\n                  this._reconnect = false;\n                }\n\n                if (this._isDisconnected()) {\n                  if (!reconnect) {\n                    this._clearConnectedState(reconnect);\n                  }\n\n                  return;\n                }\n\n                this._clearConnectedState(reconnect);\n\n                this._debug('disconnected:', reason, shouldReconnect);\n\n                this._setStatus('disconnected');\n\n                if (this._refreshTimeout) {\n                  clearTimeout(this._refreshTimeout);\n                  this._refreshTimeout = null;\n                }\n\n                if (this._reconnecting === false) {\n                  this.emit('disconnect', {\n                    reason: reason,\n                    reconnect: reconnect\n                  });\n                }\n\n                if (!this._transportClosed) {\n                  this._transport.close();\n                }\n              }\n            }, {\n              key: '_refreshFailed',\n              value: function _refreshFailed() {\n                this._numRefreshFailed = 0;\n\n                if (!this._isDisconnected()) {\n                  this._disconnect('refresh failed', false);\n                }\n\n                if (this._config.onRefreshFailed !== null) {\n                  this._config.onRefreshFailed();\n                }\n              }\n            }, {\n              key: '_refresh',\n              value: function _refresh() {\n                var _this7 = this; // ask application for new connection token.\n\n\n                this._debug('refresh token');\n\n                if (this._config.refreshAttempts === 0) {\n                  this._debug('refresh attempts set to 0, do not send refresh request at all');\n\n                  this._refreshFailed();\n\n                  return;\n                }\n\n                if (this._refreshTimeout !== null) {\n                  clearTimeout(this._refreshTimeout);\n                  this._refreshTimeout = null;\n                }\n\n                var clientID = this._clientID;\n\n                var xhrID = this._newXHRID();\n\n                var cb = function cb(resp) {\n                  if (xhrID in _this7._xhrs) {\n                    delete _this7._xhrs[xhrID];\n                  }\n\n                  if (_this7._clientID !== clientID) {\n                    return;\n                  }\n\n                  if (resp.error || resp.status !== 200) {\n                    // We don't perform any connection status related actions here as we are\n                    // relying on server that must close connection eventually.\n                    if (resp.error) {\n                      _this7._debug('error refreshing connection token', resp.error);\n                    } else {\n                      _this7._debug('error refreshing connection token: wrong status code', resp.status);\n                    }\n\n                    _this7._numRefreshFailed++;\n\n                    if (_this7._refreshTimeout !== null) {\n                      clearTimeout(_this7._refreshTimeout);\n                      _this7._refreshTimeout = null;\n                    }\n\n                    if (_this7._config.refreshAttempts !== null && _this7._numRefreshFailed >= _this7._config.refreshAttempts) {\n                      _this7._refreshFailed();\n\n                      return;\n                    }\n\n                    var jitter = Math.round(Math.random() * 1000 * Math.max(_this7._numRefreshFailed, 20));\n                    var interval = _this7._config.refreshInterval + jitter;\n                    _this7._refreshTimeout = setTimeout(function () {\n                      return _this7._refresh();\n                    }, interval);\n                    return;\n                  }\n\n                  _this7._numRefreshFailed = 0;\n                  _this7._token = resp.data.token;\n\n                  if (!_this7._token) {\n                    _this7._refreshFailed();\n\n                    return;\n                  }\n\n                  if (_this7._isDisconnected() && _this7._reconnect) {\n                    _this7._debug('token refreshed, connect from scratch');\n\n                    _this7._connect();\n                  } else {\n                    _this7._debug('send refreshed token');\n\n                    var msg = {\n                      method: _this7._methodType.REFRESH,\n                      params: {\n                        token: _this7._token\n                      }\n                    };\n\n                    _this7._call(msg).then(function (resolveCtx) {\n                      _this7._refreshResponse(_this7._decoder.decodeCommandResult(_this7._methodType.REFRESH, resolveCtx.result));\n\n                      if (resolveCtx.next) {\n                        resolveCtx.next();\n                      }\n                    }, function (rejectCtx) {\n                      _this7._refreshError(rejectCtx.error);\n\n                      if (rejectCtx.next) {\n                        rejectCtx.next();\n                      }\n                    });\n                  }\n                };\n\n                if (this._config.onRefresh !== null) {\n                  var context = {};\n\n                  this._config.onRefresh(context, cb);\n                } else {\n                  var xhr = this._ajax(this._config.refreshEndpoint, this._config.refreshParams, this._config.refreshHeaders, this._config.refreshData, cb);\n\n                  this._xhrs[xhrID] = xhr;\n                }\n              }\n            }, {\n              key: '_refreshError',\n              value: function _refreshError(err) {\n                var _this8 = this;\n\n                this._debug('refresh error', err);\n\n                if (this._refreshTimeout) {\n                  clearTimeout(this._refreshTimeout);\n                  this._refreshTimeout = null;\n                }\n\n                var interval = this._config.refreshInterval + Math.round(Math.random() * 1000);\n                this._refreshTimeout = setTimeout(function () {\n                  return _this8._refresh();\n                }, interval);\n              }\n            }, {\n              key: '_refreshResponse',\n              value: function _refreshResponse(result) {\n                var _this9 = this;\n\n                if (this._refreshTimeout) {\n                  clearTimeout(this._refreshTimeout);\n                  this._refreshTimeout = null;\n                }\n\n                if (result.expires) {\n                  this._clientID = result.client;\n                  this._refreshTimeout = setTimeout(function () {\n                    return _this9._refresh();\n                  }, this._getTTLMilliseconds(result.ttl));\n                }\n              }\n            }, {\n              key: '_newXHRID',\n              value: function _newXHRID() {\n                this._xhrID++;\n                return this._xhrID;\n              }\n            }, {\n              key: '_subRefresh',\n              value: function _subRefresh(channel) {\n                var _this10 = this;\n\n                this._debug('refresh subscription token for channel', channel);\n\n                if (this._subRefreshTimeouts[channel] !== undefined) {\n                  this._clearSubRefreshTimeout(channel);\n                } else {\n                  return;\n                }\n\n                var clientID = this._clientID;\n\n                var xhrID = this._newXHRID();\n\n                var cb = function cb(resp) {\n                  if (xhrID in _this10._xhrs) {\n                    delete _this10._xhrs[xhrID];\n                  }\n\n                  if (resp.error || resp.status !== 200 || _this10._clientID !== clientID) {\n                    return;\n                  }\n\n                  var channelsData = {};\n\n                  if (resp.data.channels) {\n                    for (var i in data.channels) {\n                      var channelData = resp.data.channels[i];\n\n                      if (!channelData.channel) {\n                        continue;\n                      }\n\n                      channelsData[channelData.channel] = channelData.token;\n                    }\n                  }\n\n                  var token = channelsData[channel];\n\n                  if (!token) {\n                    return;\n                  }\n\n                  var msg = {\n                    method: _this10._methodType.SUB_REFRESH,\n                    params: {\n                      channel: channel,\n                      token: token\n                    }\n                  };\n\n                  var sub = _this10._getSub(channel);\n\n                  if (sub === null) {\n                    return;\n                  }\n\n                  _this10._call(msg).then(function (resolveCtx) {\n                    _this10._subRefreshResponse(channel, _this10._decoder.decodeCommandResult(_this10._methodType.SUB_REFRESH, resolveCtx.result));\n\n                    if (resolveCtx.next) {\n                      resolveCtx.next();\n                    }\n                  }, function (rejectCtx) {\n                    _this10._subRefreshError(channel, rejectCtx.error);\n\n                    if (rejectCtx.next) {\n                      rejectCtx.next();\n                    }\n                  });\n                };\n\n                var data = {\n                  client: this._clientID,\n                  channels: [channel]\n                };\n\n                if (this._config.onPrivateSubscribe !== null) {\n                  this._config.onPrivateSubscribe({\n                    data: data\n                  }, cb);\n                } else {\n                  var xhr = this._ajax(this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);\n\n                  this._xhrs[xhrID] = xhr;\n                }\n              }\n            }, {\n              key: '_clearSubRefreshTimeout',\n              value: function _clearSubRefreshTimeout(channel) {\n                if (this._subRefreshTimeouts[channel] !== undefined) {\n                  clearTimeout(this._subRefreshTimeouts[channel]);\n                  delete this._subRefreshTimeouts[channel];\n                }\n              }\n            }, {\n              key: '_subRefreshError',\n              value: function _subRefreshError(channel, err) {\n                var _this11 = this;\n\n                this._debug('subscription refresh error', channel, err);\n\n                this._clearSubRefreshTimeout(channel);\n\n                var sub = this._getSub(channel);\n\n                if (sub === null) {\n                  return;\n                }\n\n                var jitter = Math.round(Math.random() * 1000);\n                var subRefreshTimeout = setTimeout(function () {\n                  return _this11._subRefresh(channel);\n                }, this._config.subRefreshInterval + jitter);\n                this._subRefreshTimeouts[channel] = subRefreshTimeout;\n                return;\n              }\n            }, {\n              key: '_subRefreshResponse',\n              value: function _subRefreshResponse(channel, result) {\n                var _this12 = this;\n\n                this._debug('subscription refresh success', channel);\n\n                this._clearSubRefreshTimeout(channel);\n\n                var sub = this._getSub(channel);\n\n                if (sub === null) {\n                  return;\n                }\n\n                if (result.expires === true) {\n                  var subRefreshTimeout = setTimeout(function () {\n                    return _this12._subRefresh(channel);\n                  }, this._getTTLMilliseconds(result.ttl));\n                  this._subRefreshTimeouts[channel] = subRefreshTimeout;\n                }\n\n                return;\n              }\n            }, {\n              key: '_subscribe',\n              value: function _subscribe(sub, isResubscribe) {\n                var _this13 = this;\n\n                this._debug('subscribing on', sub.channel);\n\n                var channel = sub.channel;\n\n                if (!(channel in this._subs)) {\n                  this._subs[channel] = sub;\n                }\n\n                if (!this.isConnected()) {\n                  // subscribe will be called later\n                  sub._setNew();\n\n                  return;\n                }\n\n                sub._setSubscribing(isResubscribe);\n\n                var msg = {\n                  method: this._methodType.SUBSCRIBE,\n                  params: {\n                    channel: channel\n                  }\n                }; // If channel name does not start with privateChannelPrefix - then we\n                // can just send subscription message to Centrifuge. If channel name\n                // starts with privateChannelPrefix - then this is a private channel\n                // and we should ask web application backend for permission first.\n\n                if ((0, _utils.startsWith)(channel, this._config.privateChannelPrefix)) {\n                  // private channel.\n                  if (this._isSubscribeBatching) {\n                    this._privateChannels[channel] = true;\n                  } else {\n                    this.startSubscribeBatching();\n\n                    this._subscribe(sub);\n\n                    this.stopSubscribeBatching();\n                  }\n                } else {\n                  var recover = sub._needRecover();\n\n                  if (recover === true) {\n                    msg.params.recover = true;\n\n                    var seq = this._getLastSeq(channel);\n\n                    if (seq) {\n                      msg.params.seq = seq;\n                    }\n\n                    var gen = this._getLastGen(channel);\n\n                    if (gen) {\n                      msg.params.gen = gen;\n                    }\n\n                    var epoch = this._getLastEpoch(channel);\n\n                    if (epoch) {\n                      msg.params.epoch = epoch;\n                    }\n                  }\n\n                  this._call(msg).then(function (resolveCtx) {\n                    _this13._subscribeResponse(channel, recover, _this13._decoder.decodeCommandResult(_this13._methodType.SUBSCRIBE, resolveCtx.result));\n\n                    if (resolveCtx.next) {\n                      resolveCtx.next();\n                    }\n                  }, function (rejectCtx) {\n                    _this13._subscribeError(channel, rejectCtx.error);\n\n                    if (rejectCtx.next) {\n                      rejectCtx.next();\n                    }\n                  });\n                }\n              }\n            }, {\n              key: '_unsubscribe',\n              value: function _unsubscribe(sub) {\n                if (this.isConnected()) {\n                  // No need to unsubscribe in disconnected state - i.e. client already unsubscribed.\n                  this._addMessage({\n                    method: this._methodType.UNSUBSCRIBE,\n                    params: {\n                      channel: sub.channel\n                    }\n                  });\n                }\n              }\n            }, {\n              key: '_getTTLMilliseconds',\n              value: function _getTTLMilliseconds(ttl) {\n                // https://stackoverflow.com/questions/12633405/what-is-the-maximum-delay-for-setinterval\n                return Math.min(ttl * 1000, 2147483647);\n              }\n            }, {\n              key: 'getSub',\n              value: function getSub(channel) {\n                return this._getSub(channel);\n              }\n            }, {\n              key: '_getSub',\n              value: function _getSub(channel) {\n                var sub = this._subs[channel];\n\n                if (!sub) {\n                  return null;\n                }\n\n                return sub;\n              }\n            }, {\n              key: '_connectResponse',\n              value: function _connectResponse(result) {\n                var _this14 = this;\n\n                var wasReconnecting = this._reconnecting;\n                this._reconnecting = false;\n\n                this._resetRetry();\n\n                this._refreshRequired = false;\n\n                if (this.isConnected()) {\n                  return;\n                }\n\n                if (this._latencyStart !== null) {\n                  this._latency = new Date().getTime() - this._latencyStart.getTime();\n                  this._latencyStart = null;\n                }\n\n                this._clientID = result.client;\n\n                this._setStatus('connected');\n\n                if (this._refreshTimeout) {\n                  clearTimeout(this._refreshTimeout);\n                }\n\n                if (result.expires) {\n                  this._refreshTimeout = setTimeout(function () {\n                    return _this14._refresh();\n                  }, this._getTTLMilliseconds(result.ttl));\n                }\n\n                this.startBatching();\n                this.startSubscribeBatching();\n\n                for (var channel in this._subs) {\n                  if (this._subs.hasOwnProperty(channel)) {\n                    var sub = this._subs[channel];\n\n                    if (sub._shouldResubscribe()) {\n                      this._subscribe(sub, wasReconnecting);\n                    }\n                  }\n                }\n\n                this.stopSubscribeBatching();\n                this.stopBatching();\n\n                this._startPing();\n\n                var ctx = {\n                  client: result.client,\n                  transport: this._transportName,\n                  latency: this._latency\n                };\n\n                if (result.data) {\n                  ctx.data = result.data;\n                }\n\n                this.emit('connect', ctx);\n              }\n            }, {\n              key: '_stopPing',\n              value: function _stopPing() {\n                if (this._pongTimeout !== null) {\n                  clearTimeout(this._pongTimeout);\n                  this._pongTimeout = null;\n                }\n\n                if (this._pingTimeout !== null) {\n                  clearTimeout(this._pingTimeout);\n                  this._pingTimeout = null;\n                }\n              }\n            }, {\n              key: '_startPing',\n              value: function _startPing() {\n                var _this15 = this;\n\n                if (this._config.ping !== true || this._config.pingInterval <= 0) {\n                  return;\n                }\n\n                if (!this.isConnected()) {\n                  return;\n                }\n\n                this._pingTimeout = setTimeout(function () {\n                  if (!_this15.isConnected()) {\n                    _this15._stopPing();\n\n                    return;\n                  }\n\n                  _this15.ping();\n\n                  _this15._pongTimeout = setTimeout(function () {\n                    _this15._disconnect('no ping', true);\n                  }, _this15._config.pongWaitTimeout);\n                }, this._config.pingInterval);\n              }\n            }, {\n              key: '_restartPing',\n              value: function _restartPing() {\n                this._stopPing();\n\n                this._startPing();\n              }\n            }, {\n              key: '_subscribeError',\n              value: function _subscribeError(channel, error) {\n                var sub = this._getSub(channel);\n\n                if (!sub) {\n                  return;\n                }\n\n                if (!sub._isSubscribing()) {\n                  return;\n                }\n\n                if (error.code === 0 && error.message === _errorTimeout) {\n                  // client side timeout.\n                  this._disconnect('timeout', true);\n\n                  return;\n                }\n\n                sub._setSubscribeError(error);\n              }\n            }, {\n              key: '_subscribeResponse',\n              value: function _subscribeResponse(channel, isRecover, result) {\n                var _this16 = this;\n\n                var sub = this._getSub(channel);\n\n                if (!sub) {\n                  return;\n                }\n\n                if (!sub._isSubscribing()) {\n                  return;\n                }\n\n                var recovered = false;\n\n                if ('recovered' in result) {\n                  recovered = result.recovered;\n                }\n\n                sub._setSubscribeSuccess(recovered);\n\n                var pubs = result.publications;\n\n                if (pubs && pubs.length > 0) {\n                  pubs = pubs.reverse();\n\n                  for (var i in pubs) {\n                    if (pubs.hasOwnProperty(i)) {\n                      this._handlePublication(channel, pubs[i]);\n                    }\n                  }\n                }\n\n                if (result.recoverable && (!isRecover || !recovered)) {\n                  this._lastSeq[channel] = result.seq || 0;\n                  this._lastGen[channel] = result.gen || 0;\n                }\n\n                this._lastEpoch[channel] = result.epoch || '';\n\n                if (result.recoverable) {\n                  sub._recoverable = true;\n                }\n\n                if (result.expires === true) {\n                  var subRefreshTimeout = setTimeout(function () {\n                    return _this16._subRefresh(channel);\n                  }, this._getTTLMilliseconds(result.ttl));\n                  this._subRefreshTimeouts[channel] = subRefreshTimeout;\n                }\n              }\n            }, {\n              key: '_handleReply',\n              value: function _handleReply(reply, next) {\n                var id = reply.id;\n                var result = reply.result;\n\n                if (!(id in this._callbacks)) {\n                  next();\n                  return;\n                }\n\n                var callbacks = this._callbacks[id];\n                clearTimeout(this._callbacks[id].timeout);\n                delete this._callbacks[id];\n\n                if (!(0, _utils.errorExists)(reply)) {\n                  var callback = callbacks.callback;\n\n                  if (!callback) {\n                    return;\n                  }\n\n                  callback({\n                    result: result,\n                    next: next\n                  });\n                } else {\n                  var errback = callbacks.errback;\n\n                  if (!errback) {\n                    next();\n                    return;\n                  }\n\n                  var error = reply.error;\n                  errback({\n                    error: error,\n                    next: next\n                  });\n                }\n              }\n            }, {\n              key: '_handleJoin',\n              value: function _handleJoin(channel, join) {\n                var sub = this._getSub(channel);\n\n                if (!sub) {\n                  return;\n                }\n\n                sub.emit('join', {\n                  'info': join.info\n                });\n              }\n            }, {\n              key: '_handleLeave',\n              value: function _handleLeave(channel, leave) {\n                var sub = this._getSub(channel);\n\n                if (!sub) {\n                  return;\n                }\n\n                sub.emit('leave', {\n                  'info': leave.info\n                });\n              }\n            }, {\n              key: '_handleUnsub',\n              value: function _handleUnsub(channel, unsub) {\n                var sub = this._getSub(channel);\n\n                if (!sub) {\n                  return;\n                }\n\n                sub.unsubscribe();\n\n                if (unsub.resubscribe === true) {\n                  sub.subscribe();\n                }\n              }\n            }, {\n              key: '_handlePublication',\n              value: function _handlePublication(channel, pub) {\n                var sub = this._getSub(channel);\n\n                if (!sub) {\n                  return;\n                }\n\n                if (pub.seq !== undefined) {\n                  this._lastSeq[channel] = pub.seq;\n                }\n\n                if (pub.gen !== undefined) {\n                  this._lastGen[channel] = pub.gen;\n                }\n\n                sub.emit('publish', pub);\n              }\n            }, {\n              key: '_handleMessage',\n              value: function _handleMessage(message) {\n                this.emit('message', message.data);\n              }\n            }, {\n              key: '_handlePush',\n              value: function _handlePush(data, next) {\n                var push = this._decoder.decodePush(data);\n\n                var type = 0;\n\n                if ('type' in push) {\n                  type = push['type'];\n                }\n\n                var channel = push.channel;\n\n                if (type === this._pushType.PUBLICATION) {\n                  var pub = this._decoder.decodePushData(this._pushType.PUBLICATION, push.data);\n\n                  this._handlePublication(channel, pub);\n                } else if (type === this._pushType.MESSAGE) {\n                  var message = this._decoder.decodePushData(this._pushType.MESSAGE, push.data);\n\n                  this._handleMessage(message);\n                } else if (type === this._pushType.JOIN) {\n                  var join = this._decoder.decodePushData(this._pushType.JOIN, push.data);\n\n                  this._handleJoin(channel, join);\n                } else if (type === this._pushType.LEAVE) {\n                  var leave = this._decoder.decodePushData(this._pushType.LEAVE, push.data);\n\n                  this._handleLeave(channel, leave);\n                } else if (type === this._pushType.UNSUB) {\n                  var unsub = this._decoder.decodePushData(this._pushType.UNSUB, push.data);\n\n                  this._handleUnsub(channel, unsub);\n                }\n\n                next();\n              }\n            }, {\n              key: '_dispatchReply',\n              value: function _dispatchReply(reply) {\n                var next;\n                var p = new Promise(function (resolve) {\n                  next = resolve;\n                });\n\n                if (reply === undefined || reply === null) {\n                  this._debug('dispatch: got undefined or null reply');\n\n                  next();\n                  return p;\n                }\n\n                var id = reply.id;\n\n                if (id && id > 0) {\n                  this._handleReply(reply, next);\n                } else {\n                  this._handlePush(reply.result, next);\n                }\n\n                return p;\n              }\n            }, {\n              key: '_flush',\n              value: function _flush() {\n                var messages = this._messages.slice(0);\n\n                this._messages = [];\n\n                this._transportSend(messages);\n              }\n            }, {\n              key: '_ping',\n              value: function _ping() {\n                var _this17 = this;\n\n                var msg = {\n                  method: this._methodType.PING\n                };\n\n                this._call(msg).then(function (resolveCtx) {\n                  _this17._pingResponse(_this17._decoder.decodeCommandResult(_this17._methodType.PING, resolveCtx.result));\n\n                  if (resolveCtx.next) {\n                    resolveCtx.next();\n                  }\n                }, function (rejectCtx) {\n                  _this17._debug('ping error', rejectCtx.error);\n\n                  if (rejectCtx.next) {\n                    rejectCtx.next();\n                  }\n                });\n              }\n            }, {\n              key: '_pingResponse',\n              value: function _pingResponse(result) {\n                if (!this.isConnected()) {\n                  return;\n                }\n\n                this._stopPing();\n\n                this._startPing();\n              }\n            }, {\n              key: '_getLastSeq',\n              value: function _getLastSeq(channel) {\n                var lastSeq = this._lastSeq[channel];\n\n                if (lastSeq) {\n                  return lastSeq;\n                }\n\n                return 0;\n              }\n            }, {\n              key: '_getLastGen',\n              value: function _getLastGen(channel) {\n                var lastGen = this._lastGen[channel];\n\n                if (lastGen) {\n                  return lastGen;\n                }\n\n                return 0;\n              }\n            }, {\n              key: '_getLastEpoch',\n              value: function _getLastEpoch(channel) {\n                var lastEpoch = this._lastEpoch[channel];\n\n                if (lastEpoch) {\n                  return lastEpoch;\n                }\n\n                return '';\n              }\n            }, {\n              key: '_createErrorObject',\n              value: function _createErrorObject(message, code) {\n                var errObject = {\n                  message: message,\n                  code: code || 0\n                };\n                return errObject;\n              }\n            }, {\n              key: '_registerCall',\n              value: function _registerCall(id, callback, errback) {\n                var _this18 = this;\n\n                this._callbacks[id] = {\n                  callback: callback,\n                  errback: errback,\n                  timeout: null\n                };\n                this._callbacks[id].timeout = setTimeout(function () {\n                  delete _this18._callbacks[id];\n\n                  if ((0, _utils.isFunction)(errback)) {\n                    errback({\n                      error: _this18._createErrorObject(_errorTimeout)\n                    });\n                  }\n                }, this._config.timeout);\n              }\n            }, {\n              key: '_addMessage',\n              value: function _addMessage(message) {\n                var id = this._nextMessageId();\n\n                message.id = id;\n\n                if (this._isBatching === true) {\n                  this._messages.push(message);\n                } else {\n                  this._transportSend([message]);\n                }\n\n                return id;\n              }\n            }, {\n              key: 'isConnected',\n              value: function isConnected() {\n                return this._isConnected();\n              }\n            }, {\n              key: 'connect',\n              value: function connect() {\n                this._connect();\n              }\n            }, {\n              key: 'disconnect',\n              value: function disconnect() {\n                this._disconnect('client', false);\n              }\n            }, {\n              key: 'ping',\n              value: function ping() {\n                return this._ping();\n              }\n            }, {\n              key: 'startBatching',\n              value: function startBatching() {\n                // start collecting messages without sending them to Centrifuge until flush\n                // method called\n                this._isBatching = true;\n              }\n            }, {\n              key: 'stopBatching',\n              value: function stopBatching() {\n                this._isBatching = false;\n\n                this._flush();\n              }\n            }, {\n              key: 'startSubscribeBatching',\n              value: function startSubscribeBatching() {\n                // start collecting private channels to create bulk authentication\n                // request to subscribeEndpoint when stopSubscribeBatching will be called\n                this._isSubscribeBatching = true;\n              }\n            }, {\n              key: 'stopSubscribeBatching',\n              value: function stopSubscribeBatching() {\n                var _this19 = this; // create request to subscribeEndpoint with collected private channels\n                // to ask if this client can subscribe on each channel\n\n\n                this._isSubscribeBatching = false;\n                var authChannels = this._privateChannels;\n                this._privateChannels = {};\n                var channels = [];\n\n                for (var channel in authChannels) {\n                  if (authChannels.hasOwnProperty(channel)) {\n                    var sub = this._getSub(channel);\n\n                    if (!sub) {\n                      continue;\n                    }\n\n                    channels.push(channel);\n                  }\n                }\n\n                if (channels.length === 0) {\n                  this._debug('no private channels found, no need to make request');\n\n                  return;\n                }\n\n                var data = {\n                  client: this._clientID,\n                  channels: channels\n                };\n                var clientID = this._clientID;\n\n                var xhrID = this._newXHRID();\n\n                var cb = function cb(resp) {\n                  if (xhrID in _this19._xhrs) {\n                    delete _this19._xhrs[xhrID];\n                  }\n\n                  if (_this19._clientID !== clientID) {\n                    return;\n                  }\n\n                  if (resp.error || resp.status !== 200) {\n                    _this19._debug('authorization request failed');\n\n                    for (var i in channels) {\n                      if (channels.hasOwnProperty(i)) {\n                        var _channel2 = channels[i];\n\n                        _this19._subscribeError(_channel2, _this19._createErrorObject('authorization request failed'));\n                      }\n                    }\n\n                    return;\n                  }\n\n                  var channelsData = {};\n\n                  if (resp.data.channels) {\n                    for (var _i in resp.data.channels) {\n                      var channelData = resp.data.channels[_i];\n\n                      if (!channelData.channel) {\n                        continue;\n                      }\n\n                      channelsData[channelData.channel] = channelData.token;\n                    }\n                  } // try to send all subscriptions in one request.\n\n\n                  var batch = false;\n\n                  if (!_this19._isBatching) {\n                    _this19.startBatching();\n\n                    batch = true;\n                  }\n\n                  for (var _i2 in channels) {\n                    if (channels.hasOwnProperty(_i2)) {\n                      var _ret2 = function () {\n                        var channel = channels[_i2];\n                        var token = channelsData[channel];\n\n                        if (!token) {\n                          // subscription:error\n                          _this19._subscribeError(channel, _this19._createErrorObject('permission denied', 103));\n\n                          return 'continue';\n                        } else {\n                          var msg = {\n                            method: _this19._methodType.SUBSCRIBE,\n                            params: {\n                              channel: channel,\n                              token: token\n                            }\n                          };\n\n                          var _sub = _this19._getSub(channel);\n\n                          if (_sub === null) {\n                            return 'continue';\n                          }\n\n                          var recover = _sub._needRecover();\n\n                          if (recover === true) {\n                            msg.params.recover = true;\n\n                            var seq = _this19._getLastSeq(channel);\n\n                            if (seq) {\n                              msg.params.seq = seq;\n                            }\n\n                            var gen = _this19._getLastGen(channel);\n\n                            if (gen) {\n                              msg.params.gen = gen;\n                            }\n\n                            var epoch = _this19._getLastEpoch(channel);\n\n                            if (epoch) {\n                              msg.params.epoch = epoch;\n                            }\n                          }\n\n                          _this19._call(msg).then(function (resolveCtx) {\n                            _this19._subscribeResponse(channel, recover, _this19._decoder.decodeCommandResult(_this19._methodType.SUBSCRIBE, resolveCtx.result));\n\n                            if (resolveCtx.next) {\n                              resolveCtx.next();\n                            }\n                          }, function (rejectCtx) {\n                            _this19._subscribeError(channel, rejectCtx.error);\n\n                            if (rejectCtx.next) {\n                              rejectCtx.next();\n                            }\n                          });\n                        }\n                      }();\n\n                      if (_ret2 === 'continue') continue;\n                    }\n                  }\n\n                  if (batch) {\n                    _this19.stopBatching();\n                  }\n                };\n\n                if (this._config.onPrivateSubscribe !== null) {\n                  this._config.onPrivateSubscribe({\n                    data: data\n                  }, cb);\n                } else {\n                  var xhr = this._ajax(this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);\n\n                  this._xhrs[xhrID] = xhr;\n                }\n              }\n            }, {\n              key: 'subscribe',\n              value: function subscribe(channel, events) {\n                var currentSub = this._getSub(channel);\n\n                if (currentSub !== null) {\n                  currentSub._setEvents(events);\n\n                  if (currentSub._isUnsubscribed()) {\n                    currentSub.subscribe();\n                  }\n\n                  return currentSub;\n                }\n\n                var sub = new _subscription2.default(this, channel, events);\n                this._subs[channel] = sub;\n                sub.subscribe();\n                return sub;\n              }\n            }]);\n\n            return Centrifuge;\n          }(_events2.default);\n          /* WEBPACK VAR INJECTION */\n\n        }).call(exports, __webpack_require__(3));\n        /***/\n      },\n\n      /***/\n      11:\n      /***/\n      function (module, exports, __webpack_require__) {\n        \"use strict\";\n\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n\n        var _createClass = function () {\n          function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n              var descriptor = props[i];\n              descriptor.enumerable = descriptor.enumerable || false;\n              descriptor.configurable = true;\n              if (\"value\" in descriptor) descriptor.writable = true;\n              Object.defineProperty(target, descriptor.key, descriptor);\n            }\n          }\n\n          return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n          };\n        }();\n\n        var _events = __webpack_require__(6);\n\n        var _events2 = _interopRequireDefault(_events);\n\n        var _utils = __webpack_require__(7);\n\n        function _interopRequireDefault(obj) {\n          return obj && obj.__esModule ? obj : {\n            default: obj\n          };\n        }\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function _possibleConstructorReturn(self, call) {\n          if (!self) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          }\n\n          return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n        }\n\n        function _inherits(subClass, superClass) {\n          if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n          }\n\n          subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n              value: subClass,\n              enumerable: false,\n              writable: true,\n              configurable: true\n            }\n          });\n          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n        }\n\n        var _STATE_NEW = 0;\n        var _STATE_SUBSCRIBING = 1;\n        var _STATE_SUCCESS = 2;\n        var _STATE_ERROR = 3;\n        var _STATE_UNSUBSCRIBED = 4;\n\n        var Subscription = function (_EventEmitter) {\n          _inherits(Subscription, _EventEmitter);\n\n          function Subscription(centrifuge, channel, events) {\n            _classCallCheck(this, Subscription);\n\n            var _this = _possibleConstructorReturn(this, (Subscription.__proto__ || Object.getPrototypeOf(Subscription)).call(this));\n\n            _this.channel = channel;\n            _this._centrifuge = centrifuge;\n            _this._status = _STATE_NEW;\n            _this._error = null;\n            _this._isResubscribe = false;\n            _this._ready = false;\n            _this._subscriptionPromise = null;\n            _this._noResubscribe = false;\n            _this._recoverable = false;\n            _this._recover = false;\n\n            _this._setEvents(events);\n\n            _this._initializePromise();\n\n            _this._promises = {};\n            _this._promiseId = 0;\n\n            _this.on('error', function (errContext) {\n              this._centrifuge._debug('subscription error', errContext);\n            });\n\n            return _this;\n          }\n\n          _createClass(Subscription, [{\n            key: '_nextPromiseId',\n            value: function _nextPromiseId() {\n              return ++this._promiseId;\n            }\n          }, {\n            key: '_initializePromise',\n            value: function _initializePromise() {\n              var _this2 = this; // this helps us to wait until subscription will successfully\n              // subscribe and call actions such as presence, history etc in\n              // synchronous way.\n\n\n              this._ready = false;\n              this._subscriptionPromise = new Promise(function (resolve, reject) {\n                _this2._resolve = function (value) {\n                  _this2._ready = true;\n                  resolve(value);\n                };\n\n                _this2._reject = function (err) {\n                  _this2._ready = true;\n                  reject(err);\n                };\n              }).then(function () {}, function () {});\n            }\n          }, {\n            key: '_needRecover',\n            value: function _needRecover() {\n              return this._recoverable === true && this._recover === true;\n            }\n          }, {\n            key: '_setEvents',\n            value: function _setEvents(events) {\n              if (!events) {\n                return;\n              }\n\n              if ((0, _utils.isFunction)(events)) {\n                // events is just a function to handle publication received from channel.\n                this.on('publish', events);\n              } else if (Object.prototype.toString.call(events) === Object.prototype.toString.call({})) {\n                var knownEvents = ['publish', 'join', 'leave', 'unsubscribe', 'subscribe', 'error'];\n\n                for (var i = 0, l = knownEvents.length; i < l; i++) {\n                  var ev = knownEvents[i];\n\n                  if (ev in events) {\n                    this.on(ev, events[ev]);\n                  }\n                }\n              }\n            }\n          }, {\n            key: '_isNew',\n            value: function _isNew() {\n              return this._status === _STATE_NEW;\n            }\n          }, {\n            key: '_isUnsubscribed',\n            value: function _isUnsubscribed() {\n              return this._status === _STATE_UNSUBSCRIBED;\n            }\n          }, {\n            key: '_isSubscribing',\n            value: function _isSubscribing() {\n              return this._status === _STATE_SUBSCRIBING;\n            }\n          }, {\n            key: '_isReady',\n            value: function _isReady() {\n              return this._status === _STATE_SUCCESS || this._status === _STATE_ERROR;\n            }\n          }, {\n            key: '_isSuccess',\n            value: function _isSuccess() {\n              return this._status === _STATE_SUCCESS;\n            }\n          }, {\n            key: '_isError',\n            value: function _isError() {\n              return this._status === _STATE_ERROR;\n            }\n          }, {\n            key: '_setNew',\n            value: function _setNew() {\n              this._status = _STATE_NEW;\n            }\n          }, {\n            key: '_setSubscribing',\n            value: function _setSubscribing(isResubscribe) {\n              this._isResubscribe = isResubscribe || false;\n\n              if (this._ready === true) {\n                // new promise for this subscription\n                this._initializePromise();\n              }\n\n              this._status = _STATE_SUBSCRIBING;\n            }\n          }, {\n            key: '_setSubscribeSuccess',\n            value: function _setSubscribeSuccess(recovered) {\n              if (this._status === _STATE_SUCCESS) {\n                return;\n              }\n\n              this._status = _STATE_SUCCESS;\n\n              var successContext = this._getSubscribeSuccessContext(recovered);\n\n              this._recover = false;\n              this.emit('subscribe', successContext);\n\n              this._resolve(successContext);\n\n              for (var id in this._promises) {\n                clearTimeout(this._promises[id].timeout);\n\n                this._promises[id].resolve();\n\n                delete this._promises[id];\n              }\n            }\n          }, {\n            key: '_setSubscribeError',\n            value: function _setSubscribeError(err) {\n              if (this._status === _STATE_ERROR) {\n                return;\n              }\n\n              this._status = _STATE_ERROR;\n              this._error = err;\n\n              var errContext = this._getSubscribeErrorContext();\n\n              this.emit('error', errContext);\n\n              this._reject(errContext);\n\n              for (var id in this._promises) {\n                clearTimeout(this._promises[id].timeout);\n\n                this._promises[id].reject(err);\n\n                delete this._promises[id];\n              }\n            }\n          }, {\n            key: '_triggerUnsubscribe',\n            value: function _triggerUnsubscribe() {\n              this.emit('unsubscribe', {\n                channel: this.channel\n              });\n            }\n          }, {\n            key: '_setUnsubscribed',\n            value: function _setUnsubscribed(noResubscribe) {\n              this._centrifuge._clearSubRefreshTimeout(this.channel);\n\n              if (this._status === _STATE_UNSUBSCRIBED) {\n                return;\n              }\n\n              var needTrigger = this._status === _STATE_SUCCESS;\n              this._status = _STATE_UNSUBSCRIBED;\n\n              if (noResubscribe === true) {\n                this._recover = false;\n                this._noResubscribe = true;\n                delete this._centrifuge._lastSeq[this.channel];\n                delete this._centrifuge._lastGen[this.channel];\n                delete this._centrifuge._lastEpoch[this.channel];\n              }\n\n              if (needTrigger) {\n                this._triggerUnsubscribe();\n              }\n            }\n          }, {\n            key: '_shouldResubscribe',\n            value: function _shouldResubscribe() {\n              return !this._noResubscribe;\n            }\n          }, {\n            key: '_getSubscribeSuccessContext',\n            value: function _getSubscribeSuccessContext(recovered) {\n              return {\n                channel: this.channel,\n                isResubscribe: this._isResubscribe,\n                recovered: recovered\n              };\n            }\n          }, {\n            key: '_getSubscribeErrorContext',\n            value: function _getSubscribeErrorContext() {\n              var subscribeErrorContext = this._error;\n              subscribeErrorContext.channel = this.channel;\n              subscribeErrorContext.isResubscribe = this._isResubscribe;\n              return subscribeErrorContext;\n            }\n          }, {\n            key: 'ready',\n            value: function ready(callback, errback) {\n              if (this._ready) {\n                if (this._isSuccess()) {\n                  callback(this._getSubscribeSuccessContext());\n                } else {\n                  errback(this._getSubscribeErrorContext());\n                }\n              }\n            }\n          }, {\n            key: 'subscribe',\n            value: function subscribe() {\n              if (this._status === _STATE_SUCCESS) {\n                return;\n              }\n\n              this._noResubscribe = false;\n\n              this._centrifuge._subscribe(this);\n            }\n          }, {\n            key: 'unsubscribe',\n            value: function unsubscribe() {\n              this._setUnsubscribed(true);\n\n              this._centrifuge._unsubscribe(this);\n            }\n          }, {\n            key: '_methodCall',\n            value: function _methodCall(message, type) {\n              var _this3 = this;\n\n              var methodCallPromise = new Promise(function (resolve, reject) {\n                var subPromise = void 0;\n\n                if (_this3._isSuccess()) {\n                  subPromise = Promise.resolve();\n                } else if (_this3._isError()) {\n                  subPromise = Promise.reject(_this3._error);\n                } else {\n                  subPromise = new Promise(function (res, rej) {\n                    var timeout = setTimeout(function () {\n                      rej({\n                        'code': 0,\n                        'message': 'timeout'\n                      });\n                    }, _this3._centrifuge._config.timeout);\n                    _this3._promises[_this3._nextPromiseId()] = {\n                      timeout: timeout,\n                      resolve: res,\n                      reject: rej\n                    };\n                  });\n                }\n\n                subPromise.then(function () {\n                  return _this3._centrifuge._call(message).then(function (resolveCtx) {\n                    resolve(_this3._centrifuge._decoder.decodeCommandResult(type, resolveCtx.result));\n\n                    if (resolveCtx.next) {\n                      resolveCtx.next();\n                    }\n                  }, function (rejectCtx) {\n                    reject(rejectCtx.error);\n\n                    if (rejectCtx.next) {\n                      rejectCtx.next();\n                    }\n                  });\n                }, function (error) {\n                  reject(error);\n                });\n              });\n              return methodCallPromise;\n            }\n          }, {\n            key: 'publish',\n            value: function publish(data) {\n              return this._methodCall({\n                method: this._centrifuge._methodType.PUBLISH,\n                params: {\n                  channel: this.channel,\n                  data: data\n                }\n              }, this._centrifuge._methodType.PUBLISH);\n            }\n          }, {\n            key: 'presence',\n            value: function presence() {\n              return this._methodCall({\n                method: this._centrifuge._methodType.PRESENCE,\n                params: {\n                  channel: this.channel\n                }\n              }, this._centrifuge._methodType.PRESENCE);\n            }\n          }, {\n            key: 'presenceStats',\n            value: function presenceStats() {\n              return this._methodCall({\n                method: this._centrifuge._methodType.PRESENCE_STATS,\n                params: {\n                  channel: this.channel\n                }\n              }, this._centrifuge._methodType.PRESENCE_STATS);\n            }\n          }, {\n            key: 'history',\n            value: function history() {\n              return this._methodCall({\n                method: this._centrifuge._methodType.HISTORY,\n                params: {\n                  channel: this.channel\n                }\n              }, this._centrifuge._methodType.HISTORY);\n            }\n          }]);\n\n          return Subscription;\n        }(_events2.default);\n\n        exports.default = Subscription;\n        module.exports = exports['default'];\n        /***/\n      },\n\n      /***/\n      12:\n      /***/\n      function (module, exports, __webpack_require__) {\n        \"use strict\";\n\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n\n        var _createClass = function () {\n          function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n              var descriptor = props[i];\n              descriptor.enumerable = descriptor.enumerable || false;\n              descriptor.configurable = true;\n              if (\"value\" in descriptor) descriptor.writable = true;\n              Object.defineProperty(target, descriptor.key, descriptor);\n            }\n          }\n\n          return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n          };\n        }();\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        var JsonMethodType = exports.JsonMethodType = {\n          CONNECT: 0,\n          SUBSCRIBE: 1,\n          UNSUBSCRIBE: 2,\n          PUBLISH: 3,\n          PRESENCE: 4,\n          PRESENCE_STATS: 5,\n          HISTORY: 6,\n          PING: 7,\n          SEND: 8,\n          RPC: 9,\n          REFRESH: 10,\n          SUB_REFRESH: 11\n        };\n        var JsonPushType = exports.JsonPushType = {\n          PUBLICATION: 0,\n          JOIN: 1,\n          LEAVE: 2,\n          UNSUB: 3,\n          MESSAGE: 4\n        };\n\n        var JsonEncoder = exports.JsonEncoder = function () {\n          function JsonEncoder() {\n            _classCallCheck(this, JsonEncoder);\n          }\n\n          _createClass(JsonEncoder, [{\n            key: 'encodeCommands',\n            value: function encodeCommands(commands) {\n              var encodedCommands = [];\n\n              for (var i in commands) {\n                if (commands.hasOwnProperty(i)) {\n                  encodedCommands.push(JSON.stringify(commands[i]));\n                }\n              }\n\n              return encodedCommands.join('\\n');\n            }\n          }]);\n\n          return JsonEncoder;\n        }();\n\n        var JsonDecoder = exports.JsonDecoder = function () {\n          function JsonDecoder() {\n            _classCallCheck(this, JsonDecoder);\n          }\n\n          _createClass(JsonDecoder, [{\n            key: 'decodeReplies',\n            value: function decodeReplies(data) {\n              var replies = [];\n              var encodedReplies = data.split('\\n');\n\n              for (var i in encodedReplies) {\n                if (encodedReplies.hasOwnProperty(i)) {\n                  if (!encodedReplies[i]) {\n                    continue;\n                  }\n\n                  var reply = JSON.parse(encodedReplies[i]);\n                  replies.push(reply);\n                }\n              }\n\n              return replies;\n            }\n          }, {\n            key: 'decodeCommandResult',\n            value: function decodeCommandResult(methodType, data) {\n              return data;\n            }\n          }, {\n            key: 'decodePush',\n            value: function decodePush(data) {\n              return data;\n            }\n          }, {\n            key: 'decodePushData',\n            value: function decodePushData(pushType, data) {\n              return data;\n            }\n          }]);\n\n          return JsonDecoder;\n        }();\n        /***/\n\n      },\n\n      /***/\n      3:\n      /***/\n      function (module, exports) {\n        var g; // This works in non-strict mode\n\n        g = function () {\n          return this;\n        }();\n\n        try {\n          // This works if eval is allowed (see CSP)\n          g = g || Function(\"return this\")() || (1, eval)(\"this\");\n        } catch (e) {\n          // This works if the window reference is available\n          if (typeof window === \"object\") g = window;\n        } // g can still be undefined, but nothing to do about it...\n        // We return undefined, instead of nothing here, so it's\n        // easier to handle this case. if(!global) { ...}\n\n\n        module.exports = g;\n        /***/\n      },\n\n      /***/\n      31:\n      /***/\n      function (module, exports, __webpack_require__) {\n        \"use strict\";\n\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n\n        var _centrifuge = __webpack_require__(10);\n\n        exports.default = _centrifuge.Centrifuge;\n        module.exports = exports['default'];\n        /***/\n      },\n\n      /***/\n      6:\n      /***/\n      function (module, exports, __webpack_require__) {\n        \"use strict\"; // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n        var R = typeof Reflect === 'object' ? Reflect : null;\n        var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n          return Function.prototype.apply.call(target, receiver, args);\n        };\n        var ReflectOwnKeys;\n\n        if (R && typeof R.ownKeys === 'function') {\n          ReflectOwnKeys = R.ownKeys;\n        } else if (Object.getOwnPropertySymbols) {\n          ReflectOwnKeys = function ReflectOwnKeys(target) {\n            return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n          };\n        } else {\n          ReflectOwnKeys = function ReflectOwnKeys(target) {\n            return Object.getOwnPropertyNames(target);\n          };\n        }\n\n        function ProcessEmitWarning(warning) {\n          if (console && console.warn) console.warn(warning);\n        }\n\n        var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n          return value !== value;\n        };\n\n        function EventEmitter() {\n          EventEmitter.init.call(this);\n        }\n\n        module.exports = EventEmitter; // Backwards-compat with node 0.10.x\n\n        EventEmitter.EventEmitter = EventEmitter;\n        EventEmitter.prototype._events = undefined;\n        EventEmitter.prototype._eventsCount = 0;\n        EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are\n        // added to it. This is a useful default which helps finding memory leaks.\n\n        var defaultMaxListeners = 10;\n        Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n          enumerable: true,\n          get: function () {\n            return defaultMaxListeners;\n          },\n          set: function (arg) {\n            if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n              throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n            }\n\n            defaultMaxListeners = arg;\n          }\n        });\n\n        EventEmitter.init = function () {\n          if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n            this._events = Object.create(null);\n            this._eventsCount = 0;\n          }\n\n          this._maxListeners = this._maxListeners || undefined;\n        }; // Obviously not all Emitters should be limited to 10. This function allows\n        // that to be increased. Set to zero for unlimited.\n\n\n        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n          if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n            throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n          }\n\n          this._maxListeners = n;\n          return this;\n        };\n\n        function $getMaxListeners(that) {\n          if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n          return that._maxListeners;\n        }\n\n        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n          return $getMaxListeners(this);\n        };\n\n        EventEmitter.prototype.emit = function emit(type) {\n          var args = [];\n\n          for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n\n          var doError = type === 'error';\n          var events = this._events;\n          if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.\n\n          if (doError) {\n            var er;\n            if (args.length > 0) er = args[0];\n\n            if (er instanceof Error) {\n              // Note: The comments on the `throw` lines are intentional, they show\n              // up in Node's output if this results in an unhandled exception.\n              throw er; // Unhandled 'error' event\n            } // At least give some kind of context to the user\n\n\n            var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n            err.context = er;\n            throw err; // Unhandled 'error' event\n          }\n\n          var handler = events[type];\n          if (handler === undefined) return false;\n\n          if (typeof handler === 'function') {\n            ReflectApply(handler, this, args);\n          } else {\n            var len = handler.length;\n            var listeners = arrayClone(handler, len);\n\n            for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\n          }\n\n          return true;\n        };\n\n        function _addListener(target, type, listener, prepend) {\n          var m;\n          var events;\n          var existing;\n\n          if (typeof listener !== 'function') {\n            throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n          }\n\n          events = target._events;\n\n          if (events === undefined) {\n            events = target._events = Object.create(null);\n            target._eventsCount = 0;\n          } else {\n            // To avoid recursion in the case that type === \"newListener\"! Before\n            // adding it to the listeners, first emit \"newListener\".\n            if (events.newListener !== undefined) {\n              target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the\n              // this._events to be assigned to a new object\n\n              events = target._events;\n            }\n\n            existing = events[type];\n          }\n\n          if (existing === undefined) {\n            // Optimize the case of one listener. Don't need the extra array object.\n            existing = events[type] = listener;\n            ++target._eventsCount;\n          } else {\n            if (typeof existing === 'function') {\n              // Adding the second element, need to change to array.\n              existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.\n            } else if (prepend) {\n              existing.unshift(listener);\n            } else {\n              existing.push(listener);\n            } // Check for listener leak\n\n\n            m = $getMaxListeners(target);\n\n            if (m > 0 && existing.length > m && !existing.warned) {\n              existing.warned = true; // No error code for this since it is a Warning\n              // eslint-disable-next-line no-restricted-syntax\n\n              var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n              w.name = 'MaxListenersExceededWarning';\n              w.emitter = target;\n              w.type = type;\n              w.count = existing.length;\n              ProcessEmitWarning(w);\n            }\n          }\n\n          return target;\n        }\n\n        EventEmitter.prototype.addListener = function addListener(type, listener) {\n          return _addListener(this, type, listener, false);\n        };\n\n        EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n        EventEmitter.prototype.prependListener = function prependListener(type, listener) {\n          return _addListener(this, type, listener, true);\n        };\n\n        function onceWrapper() {\n          var args = [];\n\n          for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n\n          if (!this.fired) {\n            this.target.removeListener(this.type, this.wrapFn);\n            this.fired = true;\n            ReflectApply(this.listener, this.target, args);\n          }\n        }\n\n        function _onceWrap(target, type, listener) {\n          var state = {\n            fired: false,\n            wrapFn: undefined,\n            target: target,\n            type: type,\n            listener: listener\n          };\n          var wrapped = onceWrapper.bind(state);\n          wrapped.listener = listener;\n          state.wrapFn = wrapped;\n          return wrapped;\n        }\n\n        EventEmitter.prototype.once = function once(type, listener) {\n          if (typeof listener !== 'function') {\n            throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n          }\n\n          this.on(type, _onceWrap(this, type, listener));\n          return this;\n        };\n\n        EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n          if (typeof listener !== 'function') {\n            throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n          }\n\n          this.prependListener(type, _onceWrap(this, type, listener));\n          return this;\n        }; // Emits a 'removeListener' event if and only if the listener was removed.\n\n\n        EventEmitter.prototype.removeListener = function removeListener(type, listener) {\n          var list, events, position, i, originalListener;\n\n          if (typeof listener !== 'function') {\n            throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n          }\n\n          events = this._events;\n          if (events === undefined) return this;\n          list = events[type];\n          if (list === undefined) return this;\n\n          if (list === listener || list.listener === listener) {\n            if (--this._eventsCount === 0) this._events = Object.create(null);else {\n              delete events[type];\n              if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n            }\n          } else if (typeof list !== 'function') {\n            position = -1;\n\n            for (i = list.length - 1; i >= 0; i--) {\n              if (list[i] === listener || list[i].listener === listener) {\n                originalListener = list[i].listener;\n                position = i;\n                break;\n              }\n            }\n\n            if (position < 0) return this;\n            if (position === 0) list.shift();else {\n              spliceOne(list, position);\n            }\n            if (list.length === 1) events[type] = list[0];\n            if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n          }\n\n          return this;\n        };\n\n        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\n        EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n          var listeners, events, i;\n          events = this._events;\n          if (events === undefined) return this; // not listening for removeListener, no need to emit\n\n          if (events.removeListener === undefined) {\n            if (arguments.length === 0) {\n              this._events = Object.create(null);\n              this._eventsCount = 0;\n            } else if (events[type] !== undefined) {\n              if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n            }\n\n            return this;\n          } // emit removeListener for all listeners on all events\n\n\n          if (arguments.length === 0) {\n            var keys = Object.keys(events);\n            var key;\n\n            for (i = 0; i < keys.length; ++i) {\n              key = keys[i];\n              if (key === 'removeListener') continue;\n              this.removeAllListeners(key);\n            }\n\n            this.removeAllListeners('removeListener');\n            this._events = Object.create(null);\n            this._eventsCount = 0;\n            return this;\n          }\n\n          listeners = events[type];\n\n          if (typeof listeners === 'function') {\n            this.removeListener(type, listeners);\n          } else if (listeners !== undefined) {\n            // LIFO order\n            for (i = listeners.length - 1; i >= 0; i--) {\n              this.removeListener(type, listeners[i]);\n            }\n          }\n\n          return this;\n        };\n\n        function _listeners(target, type, unwrap) {\n          var events = target._events;\n          if (events === undefined) return [];\n          var evlistener = events[type];\n          if (evlistener === undefined) return [];\n          if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n          return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n        }\n\n        EventEmitter.prototype.listeners = function listeners(type) {\n          return _listeners(this, type, true);\n        };\n\n        EventEmitter.prototype.rawListeners = function rawListeners(type) {\n          return _listeners(this, type, false);\n        };\n\n        EventEmitter.listenerCount = function (emitter, type) {\n          if (typeof emitter.listenerCount === 'function') {\n            return emitter.listenerCount(type);\n          } else {\n            return listenerCount.call(emitter, type);\n          }\n        };\n\n        EventEmitter.prototype.listenerCount = listenerCount;\n\n        function listenerCount(type) {\n          var events = this._events;\n\n          if (events !== undefined) {\n            var evlistener = events[type];\n\n            if (typeof evlistener === 'function') {\n              return 1;\n            } else if (evlistener !== undefined) {\n              return evlistener.length;\n            }\n          }\n\n          return 0;\n        }\n\n        EventEmitter.prototype.eventNames = function eventNames() {\n          return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n        };\n\n        function arrayClone(arr, n) {\n          var copy = new Array(n);\n\n          for (var i = 0; i < n; ++i) copy[i] = arr[i];\n\n          return copy;\n        }\n\n        function spliceOne(list, index) {\n          for (; index + 1 < list.length; index++) list[index] = list[index + 1];\n\n          list.pop();\n        }\n\n        function unwrapListeners(arr) {\n          var ret = new Array(arr.length);\n\n          for (var i = 0; i < ret.length; ++i) {\n            ret[i] = arr[i].listener || arr[i];\n          }\n\n          return ret;\n        }\n        /***/\n\n      },\n\n      /***/\n      7:\n      /***/\n      function (module, exports, __webpack_require__) {\n        \"use strict\";\n        /* WEBPACK VAR INJECTION */\n\n        (function (global) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.startsWith = startsWith;\n          exports.isFunction = isFunction;\n          exports.log = log;\n          exports.backoff = backoff;\n          exports.errorExists = errorExists;\n          exports.extend = extend;\n\n          function startsWith(value, prefix) {\n            return value.lastIndexOf(prefix, 0) === 0;\n          }\n\n          ;\n\n          function isFunction(value) {\n            if (value === undefined || value === null) {\n              return false;\n            }\n\n            return typeof value === 'function';\n          }\n\n          ;\n\n          function log(level, args) {\n            if (global.console) {\n              var logger = global.console[level];\n\n              if (isFunction(logger)) {\n                logger.apply(global.console, args);\n              }\n            }\n          }\n\n          ;\n\n          function backoff(step, min, max) {\n            var jitter = 0.5 * Math.random();\n            var interval = Math.min(max, min * Math.pow(2, step + 1));\n            return Math.floor((1 - jitter) * interval);\n          }\n\n          ;\n\n          function errorExists(data) {\n            return 'error' in data && data.error !== null;\n          }\n\n          ;\n\n          function extend(a, b) {\n            for (var key in b) {\n              if (b.hasOwnProperty(key)) {\n                a[key] = b[key];\n              }\n            }\n\n            return a;\n          }\n\n          ;\n          /* WEBPACK VAR INJECTION */\n        }).call(exports, __webpack_require__(3));\n        /***/\n      }\n      /******/\n\n    })\n  );\n});","map":null,"metadata":{},"sourceType":"script"}